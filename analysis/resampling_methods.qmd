---
title: "Spatial CV vs traditional CV"
author: "Julia Lober"
format: html
editor: visual
params:
  data_dir:
    label: Data Directory
    value: /Users/julialober/Documents/terrainworks/code/sandbox/data/
    input: text
  training_data:
    label: Training data .Rdata file
    value:  sample_wilson.Rdata
    input: text
  points:
    label: Training data points
    value:  DeanCr/DeanCr_Initiation_Points.shp
    input: text
  dem:
    label: Training data dem
    value:  DeanCr/elev_deancr.flt
    input: text
---

```{r}
#| echo: false
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  error = FALSE
)
```

```{r}
#| echo: false
load(paste0(params$data_dir, params$training_data))
pnts <- terra::vect(paste0(params$data_dir, params$points))
dem <- terra::rast(paste0(params$data_dir, params$dem))
```

```{r load, include = FALSE}
library(mlr3)
library(mlr3spatial)
library(mlr3spatiotempcv)
library(mlr3learners)
library(mlr3tuning)
library(mlr3viz)
# Packages for models - change these based on what type of model you build
library(glmnet)
library(ranger)
```

## Evaluate Spatial CV Methods vs Normal CV 

Data is loaded. First we need to look at the points on a map.

```{r}
orig_p <- par(mar = c(5, 5, 0, 5))

# plot(dem)
plot(x = sample_pnts[, "x"], y = sample_pnts[, "y"], pch = 20)
sample_pnts[, "class"] <- as.factor(sample_pnts[, "class"])

par(orig_p)

```

We want to train a logistic regression learner based on the landslide data points loaded into the data frame sample_pnts.

```{r}
task <- as_task_classif_st(x = sample_pnts[, 2:10], 
                          id = "landslide_init", 
                          target = "class", 
                          positive = "pos", 
                          coordinate_names = c("x", "y"), 
                          crs = 2992)

learner <- lrn("classif.log_reg", 
               predict_type = "prob")
```

```{r}
#| echo: false
head(sample_pnts)
```

We can start running a cluster-based spatial CV method. This method does not consider the temporal distribution of the points, but uses a k-means clustering algorithm to split the data into the defined number of regions based on their x-y coordinates. This is one of the more straight-forward methods of spatial cross-validation: divide our data into groupings that are all near each other.

> Nevertheless, despite the random selection of initial cluster centers, repeated partitionings may in some cases be nearly identical. Also, k-means clustering may be less suitable for data sets with pre-existing clusters of points and/or with isolated, distant sample locations. When distinct clusters of points are present, as in multi-level sampling, it may be better to define clusters using a factor variable. ([mlr3spatiotempcv reference](https://arxiv.org/pdf/2110.12674.pdf))

```{r}
set.seed(12345)
rsmp_clus <- rsmp("spcv_coords", 
                  folds = 5)

# rr_sp = resample(task = task, 
#                  learner = learner,
#                  resampling = resampling_sp)

autoplot(rsmp_clus, task, fold_id = c(1:5)) *
  ggplot2::scale_x_continuous(breaks = seq(124.0, 125.0, 0.4)) *
  ggplot2::scale_y_continuous(breaks = seq(55.38, 55.48, 0.2))
```

I am going to ignore the leave-one-out methods for now since we don't have many data points, and so leaving any of them out would likely have a big impact on the results that we observe (I would expect it to report lower performance than we actually observe).

Other otions we have are ("method ="):

1.  "custom_cv" - an mlr3-supported way to customize the resampling splits, using either a vector of a factor variable, or a feature of the input (e.g., altitude). I think that we may consider doing this but am not sure how we would divide (maybe we would want to consider combining a few methods?).
2.  "spcv_block" - block spatial cross validation. The whole area is divided up geometrically into blocks and one or multiple of these blocks is included in each split.
3.  "sptcv_cstf" - leave-location-out, leave-time-out, or leave-location-time-out methods. Control which method is being used by parameters "time =" and "space =". I believe this is the only way to do temporal cross-validation (aside from "custom_cv").

This is the block method. Equal-sized blocks are created and then grouped to create the number of splits. The more columns/rows are created, the closer this method would get to a non-spatial cross validation method, so this is an important factor for this method.

This method is probably not as well suited to non-rectangular study areas.

```{r}
set.seed(12345)
rsmp_block <- rsmp("spcv_block", 
                  folds = 5, 
                  cols = 4,
                  rows = 4)

autoplot(rsmp_block, task, fold_id = c(1:5), size = 1, show_blocks = TRUE)
```

We have to wait on the temporal cross-validation methods for now, since we don't have the date in our current data frame (as of 2/23).
