---
title: "Spatial CV vs traditional CV"
author: "Julia Lober"
format: html
editor: visual
params:
  data_dir:
    label: Data Directory
    value: /Users/julialober/Documents/terrainworks/code/sandbox/data/
    input: text
  training_data:
    label: Training data .Rdata file
    value:  sample_wilson.Rdata
    input: text
  points:
    label: Training data points
    value:  DeanCr/DeanCr_Initiation_Points.shp
    input: text
  dem:
    label: Training data dem
    value:  DeanCr/elev_deancr.flt
    input: text
---

```{r}
#| echo: false
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  error = FALSE
)
```

```{r}
#| echo: false
load(paste0(params$data_dir, params$training_data))
pnts <- vect(paste0(params$data_dir, params$points))
dem <- rast(paste0(params$data_dir, params$dem))
```

```{r load, include = FALSE}
library(mlr3)
library(mlr3spatial)
library(mlr3spatiotempcv)
library(mlr3learners)
library(mlr3tuning)
library(mlr3viz)
# Packages for models - change these based on what type of model you build
library(glmnet)
library(ranger)
```

## Evaluate Spatial CV Methods vs Normal CV 

Data is loaded. First we need to look at the points on a map.

```{r}
orig_p <- par(mar = c(5, 5, 0, 5))

plot(sample_pnts[, "x"], sample_pnts[, "y"], pch = 20)
sample_pnts[, "class"] <- as.factor(sample_pnts[, "class"])

par(orig_p)

```

We want to train a logistic regression learner based on the landslide data points loaded into the data frame sample_pnts.

```{r}
task <- as_task_classif_st(x = sample_pnts[, 2:10], 
                          id = "landslide_init", 
                          target = "class", 
                          positive = "pos", 
                          coordinate_names = c("x", "y"), 
                          crs = 2992)

learner <- lrn("classif.log_reg", 
               predict_type = "prob")
```

```{r}
#| echo: false
head(sample_pnts[, 2:10])
```

We can start running a cluster-based spatial CV method. This method does not consider the temporal distribution of the points, but uses a k-means clustering algorithm to split the data into the defined number of regions based on their x-y coordinates.

> Nevertheless, despite the random selection of initial cluster centers, repeated partitionings may in some cases be nearly identical. Also, k-means clustering may be less suitable for data sets with pre-existing clusters of points and/or with isolated, distant sample locations. When distinct clusters of points are present, as in multi-level sampling, it may be better to define clusters using a factor variable. ([mlr3spatiotempcv reference](https://arxiv.org/pdf/2110.12674.pdf))

```{r}
# Define the spatial resampling method. 
rsmp_clus <- rsmp("repeated_spcv_coords", 
                  folds = 5, repeats = 2)

# rr_sp = resample(task = task, 
#                  learner = learner,
#                  resampling = resampling_sp)

autoplot(rsmp_clus, task, fold_id = c(1:5), size = 1) *
  ggplot2::scale_y_continuous(breaks = seq(-3.97, -4, -0.01)) *
  ggplot2::scale_x_continuous(breaks = seq(-79.06, -79.08, -0.02))
```

I am going to ignore the leave-one-out methods for now since we don't have many data points, and so leaving any of them out would likely have a big impact on the results that we observe (I would expect it to report lower performance than we actually observe).

Other options we have are:

1.  "custom_cv" - an mlr3-supported way to customize the resampling splits, using either a vector of a factor variable, or a feature of the input (e.g., altitude). I think that we may consider doing this
2.  
